\chapter{Análisis del problema}
 
 Como todo software, esta aplicación se ha diseñado y desarrollado para cubrir una
 necesidad. En base a dicha premisa, podemos crear una descripción completa de los 
 actores así como una lista de requisitos detallada con la que se cubran los objetivos 
 propuestos.

\section{Descripción de los actores}
Vamos a disponer de dos actores: el \textbf{usuario} y el \textbf{administrador}.\\

El \textbf{usuario} será el agente de policía que desée realizar cualquiera de las acciones
disponibles en la aplicación. Este actor no tiene por qué tener ninguna experiencia previa
con aplicaciones web pero en este escenario se les ha formado con unas nociones básicas 
a modo de tutorial de como realizar todas las acciones posibles en la aplicación y las consecuencias
que tiene en el servidor.\\

El \textbf{administrador} será la persona encargada de asegurar el correcto funcionamiento 
del software así como el encargado de la gestión de los datos de usuario y de la aplicación. Este
actor, por tanto, debe tener un alto conocimiento de las tecnologías con las que se ha construido
\textbf{Chief} para poder dar una rápida respuesta a los posibles problemas del usuario.

\section{Análisis de requisitos}

Los requisitos serán divididos en 3 tipos:

\begin{itemize}
   \item \textbf{Requisitos funcionales:} Son servicios que el sistema debe proporcionar, cómo
   debería responder a entradas concretas y como debe reaccionar el sistema en situaciones 
   particulares. En algunos casos, se puede especificar explícitamente qué no debe hacer el sistema.

   \item \textbf{Requisitos no funcionales:} Son requisitos que no tienen que estar directamente relacionado
   con el funcionamiento de la aplicación sino más bien, con el proceso del desarrollo.
   
   \item \textbf{Requisitos de información:} Estos requisitos están relacionados con la información 
   que se va a guardar en el sistema.

   % Definiciones por: 
   % Chapter 6. Ian Sommerville (2006). Software Engineering, 8th ed.. ISBN 0-321-31379-8. 
\end{itemize}

Para el siguiente punto se utilizarán las siguientes abreviaturas:\\  
\begin{table}[H]
   \centering
   \label{tabla-abreviaturas}
   \begin{tabular}{|c|l|}
   \hline
   \textbf{Abreviatura} & \textbf{Significado} \\ \hline
   R.F X       & Para denotar el requisito funcional número \textit{X}.\\ \hline
   R.F X-Y     & Para denotar el subrequisito funcional número \textit{Y} de \textit{X}\\ \hline
   R.N.F X     & Para denotar el requisito no funcional número \textit{X}\\ \hline
   R.N.F X-Y   & Para denotar el subrequisito no funcional número \textit{Y} de \textit{X}\\ \hline
   R.I X       & Para denotar el requisito de información número \textit{X}\\ \hline
   R.I X-Y     & Para denotar el subrequisito de información número \textit{Y} de \textit{X}\\ \hline
   \end{tabular}
   \caption{Tabla de abreviaturas para los tipos de requisitos.}
\end{table}


\subsection{Requisitos funcionales}
Los requisitos funcionales del desarrollo son los siguientes: 

\begin{itemize}
	
	\item \textbf{R.F 1}. Administración de los agentes.
	\begin{itemize}
		\item \textbf{R.F 1.1}. Registro de los agentes.
		\item \textbf{R.F 1.2}. Acceso de los agentes.
		\item \textbf{R.F 1.2}. Cerrar sesión.
	\end{itemize}

	\item \textbf{R.F 2}. Administración de turnos.
	\begin{itemize}
		\item \textbf{R.F 2.1}. Crear un documento de turno.
		\item \textbf{R.F 2.2}. Crear una nueva incidencia.
		\item \textbf{R.F 2.3}. Finalizar un parte de servicio.
	\end{itemize}

	\item \textbf{R.F 3}. Creación de ordenanzas.
	\begin{itemize}
		\item \textbf{R.F 3.1}. Crear una ordenanza de limpieza.
		\item \textbf{R.F 3.2}. Crear una ordenanza de ruidos.
		\begin{itemize}
			\item \textbf{R.F 3.2.1}. Crear un acta de molestias de ruidos en la vía pública.
			\item \textbf{R.F 3.2.2}. Crear un acta de molestias de ruidos en la vía domicilio.
			\item \textbf{R.F 3.2.3}. Crear un acta de molestias de ruidos en la vía local.
			\item \textbf{R.F 3.2.4}. Crear un acta de medición de ruidos.
		\end{itemize}
		\item \textbf{R.F 3.3}. Crear una ordenanza de obras.
		\begin{itemize}
			\item \textbf{R.F 3.3.1}. Crear un acta inspección de obras.
		\end{itemize}
		\item \textbf{R.F 3.4}. Crear una ordenanza de residuos.
		\begin{itemize}
			\item \textbf{R.F 3.3.1}. Crear un acta hallazgo de residuos.
		\end{itemize}
	\end{itemize}

	\item \textbf{R.F 4}. Creación de partes de accidentes.
	\begin{itemize}
		\item \textbf{R.F 4.1}. Crear parte de accidente de 2 vehículos.
		\item \textbf{R.F 4.2}. Crear parte de accidente de 3 vehículos.
	\end{itemize}

	\item \textbf{R.F 5}. Administrar croquis.
	\begin{itemize}
		\item \textbf{R.F 5.1}. Crear un croquis.
		\item \textbf{R.F 5.2}. Enviar un croquis.
	\end{itemize}


\end{itemize}

\subsection{Requisitos no funcionales}
Los requisitos no funcionales del desarrollo son los siguientes: 

\begin{itemize}
	\item \textbf{R.N.F 1}. La aplicación se aprovisionará automáticamente.
	\item \textbf{R.N.F 2}. Se utilizarán solamente módulos NPM como dependencias del sistema. 
	\item \textbf{R.N.F 3}. Se desplegará en una máquina virtual en un entorno controlado.
	\item \textbf{R.N.F 5}. Se creará la estructura de directorios necesaria de manera automática. 
	\item \textbf{R.N.F 5}. Para utilizar el sistema de documentos se deberán proporcionar las plantillas.
	\item \textbf{R.N.F 6}. La creación de las máquinas virtuales se realizará automáticamente.
	\item \textbf{R.N.F 7}. La base de datos se creará sin necesidad de administrarla.
\end{itemize}

\subsection{Requisitos de información}
La base de datos de la aplicación almacenará los mínimos datos necesarios para aumentar la seguridad del 
sistema:

\begin{itemize}
	\item \textbf{R.I 1}. Datos de usuario.
	\begin{itemize}
		\item Información necesaria para poder identificar a los usuarios del sistema.
		\item ID interno, usuario, contraseña, email, nombre y apellidos.
	\end{itemize}

	\item \textbf{R.I 2}. Datos de incidencias.
	\begin{itemize}
		\item Información necesaria para poder definir correctamente una incidencia dentro de un parte de servicio.
		\item Número identificador, fecha, hora, dependencia, central, número de agente, hecho y actuación.
	\end{itemize}
\end{itemize}

\section{Análisis de las soluciones}

Como en el desarrollo de cualquier software, no existe una solución única. Por tanto, se deben analizar las
distintas tecnologías que hay en el mercado para garantizar que la solución propuesta es la más adecuada para
los problemas que se plantean.\\

\subsection{Back-end}

\subsubsection{Elección del servidor} 
A la hora de implementar un servidor web tenemos un amplio abanico de tecnologías disponibles. Aunque, en este caso
en concreto, se le ha añadido una restricción y es que el servidor debe ser \textit{open-source}. Para obtener
una idea global podemos observar el siguiente gráfico comparativo del uso de servidores web actual:

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{imagenes/web-servers-comparison.png}
	\caption{Comparativa de servidores web.\cite{web-server-usage} \label{fig:figura2}}
\end{figure}

Es inmediato captar la superioridad de Apache\cite{apache} en esta gráfica. Esto es debido a que su lanzamiento 
oficial fue en el año 1996. En esta época no tuvo ningún rival y por tanto se posicionó el primero en el mercado, 
persistiendo aún hoy en día en un gran número de equipos.\\

Sin embargo, en esta lista de servidores todos siguen el esquema tradicional en el que cada petición es atendida 
por una hebra. En la situación actual del desarrollo web, se está optando por una nueva metodología. La programación
asíncrona orientada a eventos. En este tipo de arquitecturas se consigue un mejor rendimiento con un menor coste 
de recursos. \\

En la siguiente imagen podemos ver la diferencia entre un sistema convencional y el utilizado por Node.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.45]{imagenes/traditional-vs-nodejs.jpg}
	\caption{Sistema convencional vs Node \label{fig:figura3}}
\end{figure}



El único servidor web que presenta este tipo de arquitectura es Node.js y es por ello por lo que está
ganando popularidad a medida que pasa el tiempo. Su porcentaje de uso aún es bajo debido a que es una tecnología 
bastante nueva y que está ganando popularidad en los últimos años, como podemos comprobar en el siguiente gráfico
de tendencia:

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{imagenes/nodejs-trend.png}
	\caption{Gráfico de tendencia de Node.js \cite{nodejs-trend} \label{fig:figura4}}
\end{figure}

Además, Node.js dispone de \textit{npm}, que es la herramienta de gestión de paquetes por defecto de Node. Lo impresionante
de este proyecto es la acogida que ha tenido, adquiriendo decenas de miles de usuarios que, además, se involucran
activamente en el desarrollo. De esta manera consiguen una mejora constante del software. Por tanto, se ha logrande
un gran número de paquetes y hace que el desarrollo con Node sea más liviano. Podemos utilizar paquetes que 
ha desarrollado la comunidad de una manera muy sencilla, ahorrando costes en el tiempo del desarrollo.


%Sin embargo, Apache logró su máxima cuota de mercado en el año 2005, siendo usado en el 70\% de los servidores web.
%Desde entonces ha disminuido hasta la cifra actual y según la línea de tendencia continuará descendiendo como podemos
%comprobar en la siguiente gráfica:

%\begin{figure}[H]
%	\centering
%	\includegraphics[scale=0.75]{imagenes/apache-trend.png}
%	\caption{tendencia de uso de Apache.\cite{web-server-usage} \label{fig:figura2}}
%\end{figure}


\subsubsection{Elección de la base de datos}

En este apartado tenemos dos grandes corrientes: bases de datos relacionales o no relacionales. Dicho de otra manera,
bases de datos \textbf{SQL} o \textbf{NoSQL}. Ambas son opciones completamente válidas pero tienen sus diferencias.\\

Las bases de datos SQL utilizan un lenguaje de consulta estructurada(\textit{Structured Query Language}) para manipular
y definir los datos. Este tipo de consulta es una de las más usadas y es muy útil para realizar consultas complejas. 
Pero, por otro lado es muy restrictiva ya que te exige definir la estructura de los datos que vas a guardar \textbf{antes} 
de realizar cualquier operación y comenzar a trabajar. Esto impacta de manera directa con el tiempo que se debe dedicar a 
la preparación y al planteamiento de los datos que vamos a utilizar y guardar, ya que modificar dicha estructura posteriormente
puede ser realmente costoso y provocar una desestabilización completa.\\

Por otra parte, las bases de datos NoSQL tienen una esquema dinámico para gestionar los datos no estructurados. Eso se puede
traducir directamente en las siguientes características:

\begin{itemize}
	\item Se pueden añadir datos sin haber definido previamente su estructura.
	\item Los campos puede cambiar con el tiempo, incluso aparecer o desaparecer.
	\item Cada documento puede tener su propia estructura.
\end{itemize}

Una vez presentadas ambas opciones, podemos comparar sus características y optar por la que mejor se adapte a nuestro producto.

\renewcommand{\arraystretch}{2}
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{%
	\begin{tabular}{ccc}
		\rowcolor[HTML]{ECF4FF} 
		& \textbf{SQL}                                                                                                     & \textbf{NoSQL}                                                                                                               \\
		\cellcolor[HTML]{ECF4FF}\textbf{Datos}        & Estructurados en tablas                                                                                          & No estructurados en ficheros JSON                                                                                            \\
		\rowcolor[HTML]{EFEFEF} 
		\cellcolor[HTML]{ECF4FF}\textbf{Esquema}      & Estático                                                                                                         & Dinámico o flexible                                                                                                          \\
		\cellcolor[HTML]{ECF4FF}\textbf{Escalablidad} & Vertical                                                                                                         & Horizontal                                                                                                                   \\
		\rowcolor[HTML]{EFEFEF} 
		\cellcolor[HTML]{ECF4FF}\textbf{OLTP}         & Recomendada para este tipo de sistemas                                                                           & Menos utilizadas en estos sistemas                                                                                           \\
		\cellcolor[HTML]{ECF4FF}\textbf{Consistencia} & ACID\cite{acid}                                                                                                  & Teorema  CAP\cite{cap}                                                                                                                  \\
		\rowcolor[HTML]{EFEFEF} 
		\cellcolor[HTML]{ECF4FF}\textbf{Rendimiento}  & \begin{tabular}[c]{@{}l@{}}Inversamente proporcional al volumen \\ de datos almacenado actualmente.\end{tabular} & \begin{tabular}[c]{@{}l@{}}Alto y con posibilidad de mejora a costa \\ de reducir la consistencia de los datos.\end{tabular}
	\end{tabular}}
	\caption{Bases de datos SQL vs NoSQL}
\end{table}

Una vez comparadas ambas, podemos comprobar que las bases de datos SQL son especialmente útiles en sistemas robustos, muy bien definidos desde el principio
en el que no se esperan cambios en la estructura mientras que las NoSQL son útiles cuando buscamos un sistema de bases de datos que se adapte en función
de las necesidades del usuario o del propio desarrollo.


\subsection{Front-end}

Debido a que se a priorizado el desarrollo del back-end y su correcto funcionamiento, en esta parte se han optado por tecnologías probadas y 
ya conocidas por mi.

\subsubsection{Elección del motor de plantillas}

Se ha elegido Pug\cite{pug} ya que es un motor de plantillas de alto rendimiento. Este motor de plantillas era conocido anteriormente como Jade\cite{jade}, pero al tiempo
los desarrolladores se dieron cuenta de que esa marca ya estaba registrada y por tanto tuvieron que cambiar el nombre al proyecto. Cabe destacar,
que debido a la popularidad de Jade, se sigue utilizando en algunas webs pero el paquete ya no cuenta con el soporte oficial y todas las actualizaciones se lanzarán bajo el nuevo nombre. 

\subsubsection{Elección del framework CSS}

En \textbf{Chief} se perseguía conseguir una interfaz sencilla para que fuese lo más simple posible de cara al usuario. De esta manera, la curva de aprendizaje
para utilizar el producto sería mínima. Por tanto, se ha optado por elegir Bootstrap.\\

Boostrap\cite{bootstrap} es la herramienta \textit{open-source} para desarrollo web por excelencia. Es uno de los proyectos libres más populares y utilizado por toda la comunidad.
Fue creado por un trabajador de Twitter a mediados del 2010. Antes de ser el proyecto libre que es ahora, era privado ya que Twitter poseía los derechos sobre el mismo.
Pero todo cambió cuando Twitter celebró su primera Hack Week\cite{hack-week} y vieron la acogida del proyecto por parte de toda la comunidad de desarrolladores. Siguió en desarrollo
durante un año después de dicho evento y, finalmente, se publicó la primera versión del \textit{framework} tan conocido a día de hoy.\\

Debido a su simpleza a la hora de ser utilizado y a lo sencilla que es su sintáxis, puedes crear páginas web completamente adaptables de una manera muy rápida e intuitiva.

\section{Solución propuesta}

En base al análisis anterior, se ha decidido utilizar como dato base para la aplicación JSON\cite{json}.

El motivo principal es que debido a las características del desarrollo a realizar y los requerimientos del sistema,
una base de datos \textbf{NoSQL} era la opción idónea para este software. Esto es debido a que como hemos comprobado,
es una base de datos muy flexible, y que permite la incorporación de nuevos campos sin provocar grandes problemas en 
la base de datos ni desestructurarla por completo.\\

Además, dado que el objetivo del desarrollo es conseguir un prototipo funcional, con el tiempo se le podrán añadir
nuevas funcionalidades, nuevos tipos de usuarios, nuevos campos a las incidencias... Por tanto, para garantizar 
la consistencia del sistema se ha optado por este tipo de base de datos.\\

Finalmente, después de un estudio completo de las tecnologías más usadas actualmente, la solución al problema inicial se ha conseguido 
mediante el uso de las siguientes tecnologías.

\subsection{Node.js}

Node.js es un entorno de ejecución para JavaScript construido con el motor de JavaScript
V8 de Chrome. En este proyecto se ha utilizado para elaborar el servidor de la aplicación.\\

Node.js tiene una característica que lo diferencia del resto de posibilidades para implementar 
el servidor y es que utiliza un modelo de operaciones E/S sin bloqueo y orientado a eventos 
asícronos. Esto nos ofrece la la posibilidad para que cuando se detecte una conexión se atienda
pero el resto del tiempo estará inactivo. Con este nuevo modelo conseguimos servidores altamente 
escalables de una manera muy sencilla, rápida y eficiente.\\

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.25]{imagenes/nodejs_system.jpg}
	\caption{Sistema de Nodejs \label{fig:figura1}}
\end{figure}

Este diseño contrasta directamente con el modelo con el modelo de concurrencia más común hoy en 
día en el que se usan hilos del Sistema Operativo. Las operaciones en red basadas en este modelo
son relativamente ineficientes además de complejas en su uso. Cabe mencionar que, aunque Node.js 
no utilice hilos del Sistema Operativo implique que no podamos aprovechar los múltiples cores
de nuestro sistema.\\

Otro punto a favor de Node.js es que no tendremos que preocuparnos por la posibilidad de un 
bloqueo en el proceso debido a que no existe dicha posibilidad por la naturaleza de dicha 
tecnología, la cual está basada en un bucle de eventos.

\subsection{MongoDB}

MongoDB es un sistema de base de datos multiplataforma y orientado a documentos de esquema libre.
Esto quiere decir que cada entrada puede tener un esquema de datos diferente al anterior, por
lo que podemos tener entradas que difieran en el número de atributos entre sí.\\

Debido a esta característica los datos no son guardados en registros, como en las bases SQL, 
sino que se guardan en documentos. Estos archivos son del tipo BSON, que es una representación
binaria de los archivos JSON.\\

Esta tecnología ha sido escrita en C++, por lo que está en contacto con el \textit{bare metal}. Esto
último es realmente importante ya que le permite optimizar los recursos y acceder a ellos de una 
manera extremadamente eficiente, con lo que consigue una velocidad muy alta en todas sus operaciones.\\

Cabe mencionar que MongoDB es una plataforma completamente distribuida, lo que nos proporciona 
un nuevo nivel de escalabilidad y disponibilidad. Esto quiere decir que a medida que nuestro desarrollo
crezca tanto en volumen de datos como en rendimiento MongoDB se escala automáticamente sin tiempos
de caída y sin cambios en nuestra aplicación.\\

Mediante la utilización del paquete de \textit{npm} llamado \textit{Mongoose}\cite{mongoose}, la integración de MongoDB
con Node.js se realiza de una manera muy sencilla y rápida, por lo que la utilización de este módulo
cuando trabajamos con ambas tecnologías es ideal. En la siguiente imagen se define el flujo de datos
estándar cuando trabajamos con este esquema:

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.28]{imagenes/node-mongo.PNG}
	\caption{Flujo de datos con Node.js, Mongoose y MongoDB. \label{fig:figura5}}
\end{figure}


Por último, cabe mencionar que la licencia de esta tecnología es GNU AGPL 3.0\cite{agpl}, por lo que se trata de un software con licencia
libre.


% gráficas de uso frente al resto de bbdd

\subsection{Vagrant}

Vagrant es una herramienta para construir y administrar entornos de máquinas virtuales de una 
manera sencilla. Debido a que está diseñado para ser sencillo de utilizar y a que se centra en 
la automatización hace que utilicemos el menor tiempo posible en la preparación del entorno virtual
que necesitamos para comenzar a trabajar.\\

Nos proporciona un entorno muy rápido y simple de configurar, reproducible y portable utilizando
tecnología puntera en el sector de la virtualización como puede ser VirtualBox, VMWare, AWS, Docker...\\

Una enorme ventaja que aporta Vagrant al desarrollo es la posibilidad de aislar toda la configuración
del entorno y todas sus dependencias. Además, no tiene que deshacerse de las herramientras de trabajo
a las que está acostumbrado, pues realmente se sigue trabajando en el mismo entorno. 
De esta manera se consigue un desarrollo más eficiente y con mínimas pérdidas de tiempo, garantizando 
de manera directa una eficiencia en la gestión de los recursos humanos empleados.\\

En la siguiente imagen se puede ver como funciona el flujo de trabajo utilizando esta herramienta:

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{imagenes/vagrant-workflow.png}
	\caption{Flujo de trabajo de Vagrant. \label{fig:figura6}}
\end{figure}

% insertar vagrant advantages


\subsection{Ansible}

Ansible\cite{ansible} es un software que se ha diseñado explícitamente para automatizar acciones y
conseguir una mayor productividad. De esta manera, se libera al equipo de tareas costosas
y que siempre siguen el mismo proceso.\\

Ansible está categorizado bajo el nombre de \textbf{herramineta de orquestación} debido a 
las funciones que realiza. Se encarga de manejar nodos a través de SSH habiendo recibido
una entrada por parte del usuario. De esta manera, se le entrega una entrada muy sencilla
y comprensible para la lectura del ser humano, que posteriormente es analizada y transformada
en una serie de tareas hacia los nodos, consiguiendo quedar completamente configurados de una
manera muy rápida y sencilla.\\


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.45]{imagenes/ansible.png}
	\caption{Arquitectura de Ansible. \label{fig:figura7}}
\end{figure}

Como podemos comprobar en la figura anterior, Ansible se encarga de realizar todas las acciones
necesarias para que nuestro software esté listo para desplegarse \textbf{de manera automática}.
De este modo, se conseguirá una mejora significable en el tiempo de despliegue de una aplicación
además de en la gestión del tiempo de los desarrolladores.\\

Es la herramienta de automatización de código libre más potente actualmente y esto es reflejado
en las estadísticas de GitHub del proyecto. Además, la comunidad está implicada muy directamente
en el desarrollo de esta herramienta ya que cuenta con más de 2.400 personas que han desarrollado
uno o varios módulos para mejorarla.

\section{Análisis de seguridad}
